# -*- coding: utf-8 -*-
"""branch and bound

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xIClNJ12-GXG7DZg1y6_9XCaYdDXL1Bm
"""

import math 
import pandas as pd
import numpy as np

def build_distance_matrix(coordinates):
  a = coordinates
  b = a.reshape(np.prod(a.shape[:-1]), 1, a.shape[-1])
  return np.sqrt(np.einsum('ijk,ijk->ij',  b - a,  b - a)).squeeze()

def copyToFinal(curr_path): 
	final_path[:N + 1] = curr_path[:] 
	final_path[N] = curr_path[0] 

def firstMin(adj, i): 
	min = maxsize 
	for k in range(N): 
		if adj[i][k] < min and i != k: 
			min = adj[i][k] 

	return min

def secondMin(adj, i): 
	first, second = maxsize, maxsize 
	for j in range(N): 
		if i == j: 
			continue
		if adj[i][j] <= first: 
			second = first 
			first = adj[i][j] 

		elif(adj[i][j] <= second and
			adj[i][j] != first): 
			second = adj[i][j] 

	return second 

def TSPRec(adj, curr_bound, curr_weight, 
			level, curr_path, visited): 
	global final_res 

	if level == N: 

		if adj[curr_path[level - 1]][curr_path[0]] != 0: 

			curr_res = curr_weight + adj[curr_path[level - 1]][curr_path[0]]
			if curr_res < final_res: 
				copyToFinal(curr_path) 
				final_res = curr_res 
		return

	for i in range(N): 
		
		if (adj[curr_path[level-1]][i] != 0 and
							visited[i] == False): 
			temp = curr_bound 
			curr_weight += adj[curr_path[level - 1]][i] 

			if level == 1: 
				curr_bound -= ((firstMin(adj, curr_path[level - 1]) + firstMin(adj, i)) / 2) 
			else: 
				curr_bound -= ((secondMin(adj, curr_path[level - 1]) + firstMin(adj, i)) / 2) 

			if curr_bound + curr_weight < final_res: 
				curr_path[level] = i 
				visited[i] = True 
				
				TSPRec(adj, curr_bound, curr_weight, 
					level + 1, curr_path, visited) 

			curr_weight -= adj[curr_path[level - 1]][i] 
			curr_bound = temp 

			visited = [False] * len(visited) 
			for j in range(level): 
				if curr_path[j] != -1: 
					visited[curr_path[j]] = True

def TSP(adj): 
	
	curr_bound = 0
	curr_path = [-1] * (N + 1) 
	visited = [False] * N 

	for i in range(N): 
		curr_bound += (firstMin(adj, i) + secondMin(adj, i)) 

	curr_bound = math.ceil(curr_bound / 2) 

	visited[0] = True
	curr_path[0] = 0

	TSPRec(adj, curr_bound, 0, 1, curr_path, visited)

maxsize = float('inf') 

dataset_coordinates = "data.txt"
data = pd.read_csv(dataset_coordinates, sep = '\t')
data = data.values
names=[i[0] for i in data]
Y = np.asarray([[i[1], i[2]] for i in data])

X = build_distance_matrix(Y)
adj = X

N = len(names)

final_path = [None] * (N + 1) 

visited = [False] * N 

final_res = maxsize 

TSP(adj)

print("Minimum cost :", final_res)
print("Path Taken : ", end = '\n\t')
for i in range(N + 1):
	print(names[final_path[i]], end = '\n\t')